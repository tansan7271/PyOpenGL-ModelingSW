# Gemini와 함께하는 PyOpenGL 모델러 개발 로그

이 파일은 Computer Graphics 기말 프로젝트(SOR 모델러) 개발 과정을 기록하기 위해 생성되었습니다.
Gemini와의 대화 내용, 주요 결정 사항, 작업 흐름 등을 기록하여 언제든 개발 맥락을 다시 파악할 수 있도록 합니다.

---

## 메타: 이 로그 파일의 사용법

- 이 파일은 Gemini와의 대화 맥락과 주요 결정 사항을 기록하기 위해 사용됩니다.
- 대화 세션이 종료되거나 다시 시작될 때, Gemini가 이 파일을 참조하여 이전 작업 내용을 파악하고 일관된 지원을 제공할 수 있도록 합니다.
- 사용자가 "지금까지 나눈 대화를 맥락 파일에 업데이트해줘"라고 요청하면, Gemini는 현재까지의 대화 요약을 이 파일에 추가합니다.

---

## 프로젝트 시작 및 초기 설정

### 1. 프로젝트 목표 정의

- **사용자 요청:** 컴퓨터 그래픽스 기말 과제 수행.
- **과제 내용:**
  1. PyOpenGL을 이용한 SOR(Surface of Revolution) 3D 모델러 개발.
  2. 생성된 모델을 활용하는 미로 탐색 게임 개발.
  3. 관련 내용 보고서 작성.
- **담당 파트:** SOR 3D 모델러 개발.
- **참고 자료:** `CG_FinalProject.pdf`

### 2. 주요 요구사항 및 제약조건 분석

- **기술 스택:** Python, PyOpenGL.
- **결과물:** `.exe` 실행 파일, 소스 코드, `.dat` 모델 파일.
- **제약 조건:**
  - 생성형 AI 사용은 가능하나, 코드에 대한 완벽한 이해 필요.
  - 보고서 및 소스 코드의 유사도 검사(카피킬러) 예정. 오픈소스 활용 시 독창적인 변형 필요.

### 3. 작업 환경 설정

- **사용자 요청:** 프로젝트 진행 내용 추적을 위한 기록 파일 생성 요청.
- **생성된 파일:**
  1. `project_log.md`: 대화 및 작업 흐름 기록용.
  2. `report_notes.md`: 최종 보고서 작성을 위한 자료 수집용.
- **결정:** 이 파일들을 지속적으로 업데이트하며 프로젝트를 진행하기로 함.

---

## 기술 스택 논의 및 확정

### 1. GUI 라이브러리 논의

- **PyQt 제안:** 초기 제안으로, PyOpenGL과 호환성이 좋고 기능이 강력한 PyQt를 제안함.
- **macOS 및 .exe 빌드 우려:** 사용자는 macOS 환경에서 개발하며, 최종 제출물은 Windows용 `.exe`여야 한다는 점을 지적.
  - **해결책:** 개발은 macOS에서 진행하고, 최종 패키징 단계만 Windows 환경에서 `pyinstaller`를 사용하는 것으로 전략 수립.
- **PyQt와 표절률 우려:** 공통 프레임워크 사용 시 표절률 문제를 걱정.
  - **결론:** 라이브러리(도구) 사용 자체는 표절이 아니며, 직접 작성하는 애플리케이션 로직의 독창성이 중요함을 확인함.
- **대안 1 (Pure OpenGL UI):** PyQt 없이 OpenGL의 기본 입력 함수만으로 UI를 구현하는 방안을 논의. (장점: 독창성, 학습 효과 / 단점: 개발 시간, 복잡성)
- **대안 2 (Electron):** 팀원의 제안으로 Electron 프레임워크 사용 가능성을 검토.
  - **결론:** Python-OpenGL과의 연동 복잡성, 성능 문제, 프로젝트의 핵심을 벗어나는 과한 구조 등의 이유로 부적합하다고 판단.

### 2. 최종 결정

- 논의 끝에, 최종적으로 **PyQt5**를 사용하여 SOR 모델러를 개발하기로 확정함.

---

## 2025-11-18: 기본 구조 설정 및 3D 뷰포트 구현

### 1. 개발 원칙 수립

- **사용자 요청:** 보고서 작성 및 코드의 독창성 확보를 위해, 코드에 상세한 주석을 추가하고 `project_log.md`에 작업 내역을 구체적으로 기록할 것을 요청함.
- **결정:** 향후 모든 코드 변경 시, 상세 주석과 작업 로그 작성을 병행하기로 함.

### 2. 애플리케이션 기본 구조 구현 (`main.py`)

- **`MainWindow` 클래스:** PyQt5의 `QMainWindow`를 상속받아 메인 윈도우를 구성.
- **`OpenGLWidget` 클래스:** `QOpenGLWidget`을 상속받아 3D 그래픽을 렌더링할 영역을 구현하고, 메인 윈도우의 중앙 위젯으로 설정.
- **`OpenGLWidget`의 핵심 메서드:**
  - `initializeGL()`: OpenGL 상태 초기화 (배경색, 깊이 테스트 등).
  - `resizeGL()`: 윈도우 크기 변경에 따른 뷰포트 및 투영 행렬 조정.
  - `paintGL()`: 실제 렌더링(그리기)을 수행하는 메인 루프.
- **3D 좌표축 구현:**
  - `paintGL()` 내에서 `draw_axes()` 함수를 호출.
  - `draw_axes()`: 3D 공간의 기준점을 시각적으로 보여주기 위해, 원점에 R, G, B 색상의 X, Y, Z축을 그림. 이는 `gluLookAt`으로 설정된 카메라 시점에서 관찰됨.

### 3. UI 레이아웃 구조 설계

- `MainWindow`의 UI 설정을 `setupUI()` 메서드로 분리하여 코드 구조를 개선.
- **상단 툴바 (`QToolBar`):** 'Add Point', 'Create SOR' 등 핵심 기능을 빠르게 호출할 수 있는 액션(버튼)을 배치.
- **우측 컨트롤 패널 (`QDockWidget`):** 'Controls'라는 제목의 도킹 가능한 위젯을 추가. 내부에는 'Clear Points' 버튼 등 상세 조작을 위한 UI 요소들이 배치될 예정. 이 구조는 향후 확장성을 고려한 설계임.

### 4. 2D 편집 모드 전환 및 격자 표시

- 사용자 요구사항에 맞춰, **2D 평면에서 프로파일 곡선을 편집**하는 모드를 구현하기로 결정.
- **`view_mode` 상태 변수:** `OpenGLWidget`에 '2D' 또는 '3D' 상태를 저장하는 변수를 추가. 앱 시작 시 기본값은 '2D'.
- **조건부 렌더링:**
  - `resizeGL()`: `view_mode`가 '2D'이면 `glOrtho`를 사용한 2D 직교 투영을, '3D'이면 `gluPerspective`를 사용한 원근 투영을 설정하도록 수정.
  - `paintGL()`: `view_mode`가 '2D'이면 `draw_grid()`를, '3D'이면 `draw_axes()`를 호출하도록 분기.
- **`draw_grid()` 함수 구현:** 2D 편집의 기준이 될 수 있도록 배경에 회색 격자를 그리는 함수를 새로 추가.

### 5. 동적 격자 수정 및 마우스 입력 처리

- **동적 격자 생성:** 사용자 피드백을 반영하여, 창 크기가 변경될 때마다 `resizeGL`에서 계산된 투영 영역(`ortho_left` 등)에 맞춰 `draw_grid`가 격자를 동적으로 그리도록 수정. 이를 통해 창 크기를 조절해도 격자가 깨지지 않음.
- **마우스 입력 처리 (`mousePressEvent`):**
  - `OpenGLWidget`에 `mousePressEvent` 함수를 오버라이드하여 마우스 클릭 감지.
  - 2D 모드일 때, 클릭된 화면 좌표(픽셀)를 `glOrtho`로 설정된 월드 좌표계의 값으로 변환하는 로직 구현.
  - 변환된 (x, y) 좌표는 `self.points` 리스트에 저장되고, `self.update()`를 호출하여 화면 갱신.
- **점 그리기 및 삭제:**
  - `draw_points()`: `self.points` 리스트를 순회하며 노란색 점을 그리는 함수 추가. `paintGL`의 2D 모드에서 호출됨.
  - `clear_points()`: `self.points` 리스트를 비우는 함수 추가.
  - `MainWindow`의 'Clear Points' 버튼의 `clicked` 시그널을 `OpenGLWidget.clear_points` 함수에 연결하여 기능 활성화.

### 6. 2D/3D 뷰 모드 전환 기능 구현

- **`set_view_mode()` 메서드:** `OpenGLWidget`에 `set_view_mode(mode)` 메서드를 추가하여 `self.view_mode`를 변경하고, `resizeGL`을 호출하여 투영을 재설정하며, `update()`를 통해 화면을 갱신.
- **'Clear Points' 버튼 개선:** `clear_points()` 함수를 수정하여, 3D 뷰 모드에서 호출될 경우 점을 지우고 자동으로 2D 편집 모드로 전환되도록 함.
- **툴바 액션 연결:**
  - 'Add Point' 액션 클릭 시 `glWidget.set_view_mode('2D')` 호출.
  - 'Create SOR' 액션 클릭 시 `glWidget.set_view_mode('3D')` 호출.

### 7. 3D 뷰 렌더링 오류 수정 및 UI 로직 개선

- **3D 뷰 오류 수정 (최종):** 뷰 전환 시 렌더링이 즉시 갱신되지 않고 창 크기를 조절해야만 보이는 불안정한 상태의 원인을 분석하고 해결.
  - **원인:** 뷰 모드 전환 시 `set_view_mode`에서 `update()`만 호출할 경우, `paintGL`은 실행되지만 투영 행렬을 설정하는 `resizeGL`은 호출되지 않아 이전 모드의 투영 행렬이 그대로 사용되는 타이밍 문제.
  - **해결:** 투영 행렬 설정 로직을 `setupProjection` 함수로 분리. 이 함수를 `resizeGL` 뿐만 아니라 `paintGL` 함수 시작 부분에서도 매번 호출하도록 변경. 이로써 매 프레임마다 현재 뷰 모드에 맞는 투영 상태를 보장하여, 뷰 전환 시 즉시 올바른 화면이 렌더링되도록 문제를 완전히 해결.
- **UI 로직 개선:**
  - **역할 분리:** 'Clear Points' 버튼은 점 삭제 기능만 수행하도록 단순화. 뷰 전환은 상단 툴바('2D Edit', '3D View')가 전담하도록 역할을 명확히 분리.
  - **컨트롤 비활성화:** 3D 뷰 모드에서는 점 편집이 불가능하도록, `OpenGLWidget`에서 `viewModeChanged` 시그널을 보내면 `MainWindow`가 이를 받아 'Clear Points' 버튼을 비활성화하도록 시그널-슬롯 메커니즘을 구현.

### 8. 프로파일 곡선 시각화

- `draw_points` 함수를 수정하여, `GL_POINTS`로 점을 그리는 것에 더해 `GL_LINE_STRIP`을 사용하여 점들을 순서대로 잇는 선을 함께 그리도록 변경.
- 이를 통해 사용자는 자신이 만들고 있는 단면(프로파일)의 형태를 점을 찍는 과정에서 직관적으로 파악할 수 있게 됨.

### 9. SOR 모델 생성 준비: 단면 개수 UI 및 데이터 구조

- **단면 개수 UI 추가:** 컨트롤 패널에 'Number of Slices:' 레이블과 `QSpinBox`를 추가하여 사용자가 SOR 모델의 회전 단면 개수를 설정할 수 있도록 함. `QSpinBox`의 값 범위는 3에서 100으로 설정하고, 기본값은 30으로 지정.
- **`OpenGLWidget`에 데이터 구조 및 메서드 추가:**
  - `self.num_slices`: 회전 단면 개수를 저장하는 변수.
  - `self.sor_vertices`: 생성된 SOR 모델의 정점 데이터를 저장할 리스트.
  - `self.sor_faces`: 생성된 SOR 모델의 면 데이터를 저장할 리스트.
  - `set_num_slices(value)`: `QSpinBox`의 값 변경에 따라 `self.num_slices`를 업데이트하는 메서드.
  - `generate_sor_model()`: `self.points`를 기반으로 SOR 모델의 정점과 면 데이터를 생성하는 플레이스홀더 메서드.
  - `draw_sor_model()`: 생성된 SOR 모델을 그리는 플레이스홀더 메서드.
- **기능 연결:**
  - `set_view_mode`에서 '3D' 모드로 전환될 때, `self.points`가 존재하면 `generate_sor_model()`을 호출하여 모델 생성을 시도.
  - `paintGL`에서 '3D' 모드일 때, `self.sor_vertices`가 존재하면 `draw_sor_model()`을 호출하여 모델을 그리고, 그렇지 않으면 `draw_axes()`를 호출.
  - `clear_points` 함수가 호출될 때, `self.points`뿐만 아니라 `self.sor_vertices`와 `self.sor_faces`도 함께 초기화하여 모델 데이터를 리셋.
- **UI 활성화 제어:** `on_view_mode_changed` 슬롯에서 2D 모드일 때 `QSpinBox`를 활성화하고, 3D 모드일 때 비활성화하여 일관된 사용자 경험을 제공.

---

## 2025-11-19: 2D 편집 모드 및 UI/UX 최종 개선

사용자 피드백에 따라 2D 프로파일 편집 모드의 사용성과 시각적 완성도를 높이는 최종 수정 작업을 진행했습니다.

- **컨트롤 UI 통일성 강화:**
    - 사용자 피드백을 반영하여, 컨트롤 패널의 모든 섹션을 `QGroupBox`를 사용하여 명확하게 그룹화하고 시각적 일관성을 확보했습니다.
    - "Number of Slices"와 "Rotation Axis" 컨트롤들을 각각의 제목을 가진 `QGroupBox` 안에 배치하도록 `setupUI` 레이아웃 코드를 최종 리팩토링했습니다.
    - 각 `QGroupBox`의 상하에 `addSpacing(10)`을 추가하여 컨트롤 간 가독성을 높였습니다.
    - "Rotation Axis" 그룹박스 내의 라디오 버튼 순서를 X축, Y축 순으로 변경하고, 각 버튼에 `border-bottom` 스타일을 적용하여 2D 뷰의 축 색상(X-빨강, Y-초록)과 일치하는 색상 밑줄을 추가함으로써 직관성을 더욱 향상시켰습니다.
- **2D 렌더링 순서 조정 (Z-Fighting 해결):**
    - 2D 편집 모드에서 프로파일 선이 격자선에 가려지는 문제를 해결했습니다.
    - `draw_grid`에서 격자를 z = -0.1 깊이에, `draw_points`에서 점과 선을 z = 0.1 깊이에 그리도록 `glVertex3f`를 사용하여 렌더링 순서를 명확히 구분했습니다. 이로써 프로파일 곡선이 항상 격자 위에 표시됩니다.
- **UI 상태 관리 로직 단순화:** `on_view_mode_changed` 함수를 수정하여, 이제 두 `QGroupBox`의 활성화 상태만 제어하면 되도록 로직을 단순화하고 명확하게 만들었습니다. 이로써 2D/3D 모드 전환 시 모든 관련 컨트롤들이 일관되게 활성화/비활성화됩니다.

---

## 2025-11-19: 코드 모듈화 및 UI 기능 고도화

기존의 단일 `main.py` 파일 구조에서 벗어나, 유지보수성과 코드 가독성을 높이기 위해 대대적인 리팩토링 및 기능 추가를 진행했습니다.

### 1. 파일 구조 리팩토링 (모듈화)

- **목표:** UI(창) 관련 코드와 OpenGL 렌더링 코드를 분리하여 각 부분의 역할을 명확히 하고 독립적으로 개발할 수 있도록 함.
- **`main.py`:** 애플리케이션의 시작점(entry point) 역할만 수행하도록 코드를 최소화했습니다. 이제 `QApplication`을 생성하고 `ui_and_chang.py`에 정의된 `MainWindow`를 띄우는 역할만 담당합니다.
- **`ui_and_chang.py`:** `MainWindow` 클래스를 포함한 모든 PyQt5 UI 요소(툴바, 버튼, 컨트롤 패널 등)의 생성과 레이아웃, 그리고 UI 이벤트 처리(시그널-슬롯) 로직을 담당합니다.
- **`opengl_haeksim.py`:** `QOpenGLWidget`을 상속받는 `OpenGLWidget` 클래스가 위치하며, 모든 OpenGL 그래픽 처리(렌더링), 3D 데이터 관리(점, 모델 정점 등), 마우스 입력 처리 등 핵심 그래픽스 로직을 전담합니다.

### 2. 회전축 선택 UI 구현

- 컨트롤 패널에 "Rotation Axis" `QGroupBox`를 추가하여 SOR 모델 생성 시 사용할 회전축을 선택할 수 있는 기능을 구현했습니다.
- **UI 구성:** X축과 Y축을 선택할 수 있는 두 개의 `QRadioButton`으로 구성되며, SOR 모델의 일반적인 형태를 고려하여 Y축을 기본 선택 값으로 설정했습니다.
- **데이터 연동:** 라디오 버튼의 `toggled` 시그널은 `MainWindow`의 `_on_rotation_axis_changed` 슬롯에 연결됩니다. 이 슬롯은 `opengl_haeksim.py`의 `OpenGLWidget`에 있는 `set_rotation_axis(axis)` 메서드를 호출하여 선택된 축('X' 또는 'Y') 정보를 그래픽스 코어에 전달하고 저장합니다.

### 3. 실시간 좌표 리스트 UI 추가

- 사용자가 2D 편집 모드에서 찍은 점들의 좌표를 실시간으로 확인하고 관리할 수 있는 "Points List" UI를 `QGroupBox` 형태로 구현했습니다.
- **동적 UI 생성:** `QScrollArea`와 `QVBoxLayout`을 기반으로, 점이 추가되거나 삭제될 때마다 목록을 동적으로 다시 그립니다. 최신 점이 가장 위에 표시되도록 역순으로 목록을 생성하여 사용 편의성을 높였습니다.
- **시그널-슬롯 기반 실시간 업데이트:**
    - `OpenGLWidget`에서 점이 추가(`mousePressEvent`)되거나 삭제(`delete_point`, `clear_points`)될 때마다 `pointsChanged`라는 커스텀 시그널을 발생시킵니다.
    - `MainWindow`는 이 시그널을 `_update_point_list` 슬롯에 연결해두었습니다.
    - 시그널이 수신되면, `_update_point_list` 함수는 기존 목록을 모두 지우고 `OpenGLWidget`의 `points` 리스트에 있는 최신 데이터를 기반으로 UI를 새로 구성하여 실시간 동기화를 구현했습니다.
- **개별 점 삭제 기능:** 각 좌표 옆에 '×' 모양의 `QPushButton`을 추가했습니다. 이 버튼의 `clicked` 시그널은 특정 인덱스의 점을 삭제하는 `OpenGLWidget.delete_point(index)` 메서드와 `lambda`를 이용해 연결되어, 사용자가 원하는 점만 선택하여 삭제할 수 있습니다.

---

## 2025-11-20: 전체 코드 품질 개선 및 문서화

보고서 작성 및 향후 유지보수를 위해 프로젝트 전체 코드의 가독성과 품질을 높이는 대대적인 리팩토링 및 문서화 작업을 진행했습니다.

### 1. 목표

- **가독성 향상:** 모든 코드의 의도를 명확히 파악할 수 있도록 상세한 한글 주석과 docstring을 추가합니다.
- **구조 개선:** 각 파일과 함수가 단일 책임 원칙(SRP)에 가깝게 동작하도록 코드를 재구성하고, 중복을 제거하며, 일관된 컨벤션을 적용합니다.
- **유지보수성 확보:** 향후 기능 추가 및 수정이 용이한 구조를 만듭니다.

### 2. 주요 변경 사항

#### `main.py`
- **역할 명시:** 애플리케이션의 진입점(Entry Point)으로서의 역할이 명확히 드러나도록 파일 최상단에 상세한 docstring을 추가했습니다.
- **코드 설명 추가:** `QApplication` 생성, `MainWindow` 인스턴스화, `show()`, `exec_()` 등 각 실행 단계의 역할을 설명하는 인라인 주석을 보강했습니다.

#### `ui_and_chang.py`
- **핵심 구조 리팩토링:** 거대했던 `setupUI` 메서드를 `_create_toolbar`, `_create_controls_dock`, `_connect_signals` 등 기능별 private 헬퍼 메서드로 완벽히 분리하여, UI가 생성되는 과정을 체계적으로 파악할 수 있도록 구조를 개선했습니다.
- **컨트롤 생성 로직 분리:** `_create_controls_dock` 내부의 로직 또한 `_create_slices_group`, `_create_axis_group`, `_create_points_group`으로 세분화하여 각 UI 그룹박스의 생성 코드를 명확히 분리했습니다.
- **가독성 향상:**
    - 점 목록 UI를 업데이트하는 `_update_point_list` 내부의 레이아웃 초기화 로직을 별도의 `_clear_layout` 헬퍼 메서드로 추출하여 가독성을 높였습니다.
    - 미사용 `import` 구문을 제거하고, 내부용 메서드의 이름을 `_` 접두사로 통일하여 코드 컨벤션을 일관성 있게 맞췄습니다.
- **상세 주석:** 모든 메서드와 주요 로직에 상세한 docstring과 한글 주석을 추가하여, 각 UI 요소가 어떤 역할을 하고 어떻게 상호작용하는지 쉽게 이해할 수 있도록 문서화했습니다.

#### `opengl_haeksim.py`
- **문서화 강화:** 파일, 클래스, 모든 메서드 및 주요 속성에 상세한 한글 docstring과 주석을 추가하여, 그래픽스 코어의 동작 방식을 명확히 했습니다.
- **복잡한 로직 설명 추가:**
    - **좌표 변환:** `mousePressEvent`에서 Qt 화면 좌표를 OpenGL 월드 좌표로 변환하는 복잡한 과정에 대해, y축 변환부터 선형 보간에 이르는 각 단계를 설명하는 주석을 추가했습니다.
    - **Z-Fighting 해결:** `draw_grid`와 `draw_points`에서 2D 렌더링 시 격자와 프로파일 곡선이 겹치지 않도록 `z`값을 다르게 설정한 원리를 명시적으로 주석에 기록했습니다.
- **가독성 개선:**
    - `draw_axes`의 한 줄 짜리 코드를 축별로 여러 줄로 나누어 가독성을 크게 향상시켰습니다.
    - PyOpenGL의 `import *` 사용 관례에 대한 설명을 주석으로 추가하여, 코드의 배경지식을 보충했습니다.
- **구현 계획 구체화:** `generate_sor_model` 등 미구현된 함수의 `TODO` 주석을, 앞으로 구현해야 할 내용을 담아 더 구체적으로 수정했습니다.

이 작업을 통해 프로젝트의 모든 소스 코드는 높은 수준의 가독성과 체계적인 구조를 갖추게 되었으며, 다음 단계인 SOR 모델 생성 로직 구현을 위한 견고한 기반을 마련했습니다.