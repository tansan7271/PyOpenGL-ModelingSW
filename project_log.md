# Gemini와 함께하는 PyOpenGL 모델러 개발 로그

이 파일은 Computer Graphics 기말 프로젝트(SOR 모델러) 개발 과정을 기록하기 위해 생성되었습니다.
Gemini와의 대화 내용, 주요 결정 사항, 작업 흐름 등을 기록하여 언제든 개발 맥락을 다시 파악할 수 있도록 합니다.

---

## 메타: 이 로그 파일의 사용법

- 이 파일은 Gemini와의 대화 맥락과 주요 결정 사항을 기록하기 위해 사용됩니다.
- 대화 세션이 종료되거나 다시 시작될 때, Gemini가 이 파일을 참조하여 이전 작업 내용을 파악하고 일관된 지원을 제공할 수 있도록 합니다.
- 사용자가 "지금까지 나눈 대화를 맥락 파일에 업데이트해줘"라고 요청하면, Gemini는 현재까지의 대화 요약을 이 파일에 추가합니다.

---

## 프로젝트 시작 및 초기 설정

### 1. 프로젝트 목표 정의

- **사용자 요청:** 컴퓨터 그래픽스 기말 과제 수행.
- **과제 내용:**
  1. PyOpenGL을 이용한 SOR(Surface of Revolution) 3D 모델러 개발.
  2. 생성된 모델을 활용하는 미로 탐색 게임 개발.
  3. 관련 내용 보고서 작성.
- **담당 파트:** SOR 3D 모델러 개발.
- **참고 자료:** `CG_FinalProject.pdf`

### 2. 주요 요구사항 및 제약조건 분석

- **기술 스택:** Python, PyOpenGL.
- **결과물:** `.exe` 실행 파일, 소스 코드, `.dat` 모델 파일.
- **제약 조건:**
  - 생성형 AI 사용은 가능하나, 코드에 대한 완벽한 이해 필요.
  - 보고서 및 소스 코드의 유사도 검사(카피킬러) 예정. 오픈소스 활용 시 독창적인 변형 필요.

### 3. 작업 환경 설정

- **사용자 요청:** 프로젝트 진행 내용 추적을 위한 기록 파일 생성 요청.
- **생성된 파일:**
  1. `project_log.md`: 대화 및 작업 흐름 기록용.
  2. `report_notes.md`: 최종 보고서 작성을 위한 자료 수집용.
- **결정:** 이 파일들을 지속적으로 업데이트하며 프로젝트를 진행하기로 함.

---

## 기술 스택 논의 및 확정

### 1. GUI 라이브러리 논의

- **PyQt 제안:** 초기 제안으로, PyOpenGL과 호환성이 좋고 기능이 강력한 PyQt를 제안함.
- **macOS 및 .exe 빌드 우려:** 사용자는 macOS 환경에서 개발하며, 최종 제출물은 Windows용 `.exe`여야 한다는 점을 지적.
  - **해결책:** 개발은 macOS에서 진행하고, 최종 패키징 단계만 Windows 환경에서 `pyinstaller`를 사용하는 것으로 전략 수립.
- **PyQt와 표절률 우려:** 공통 프레임워크 사용 시 표절률 문제를 걱정.
  - **결론:** 라이브러리(도구) 사용 자체는 표절이 아니며, 직접 작성하는 애플리케이션 로직의 독창성이 중요함을 확인함.
- **대안 1 (Pure OpenGL UI):** PyQt 없이 OpenGL의 기본 입력 함수만으로 UI를 구현하는 방안을 논의. (장점: 독창성, 학습 효과 / 단점: 개발 시간, 복잡성)
- **대안 2 (Electron):** 팀원의 제안으로 Electron 프레임워크 사용 가능성을 검토.
  - **결론:** Python-OpenGL과의 연동 복잡성, 성능 문제, 프로젝트의 핵심을 벗어나는 과한 구조 등의 이유로 부적합하다고 판단.

### 2. 최종 결정

- 논의 끝에, 최종적으로 **PyQt5**를 사용하여 SOR 모델러를 개발하기로 확정함.

---

## 2025-11-18: 기본 구조 설정 및 3D 뷰포트 구현

### 1. 개발 원칙 수립

- **사용자 요청:** 보고서 작성 및 코드의 독창성 확보를 위해, 코드에 상세한 주석을 추가하고 `project_log.md`에 작업 내역을 구체적으로 기록할 것을 요청함.
- **결정:** 향후 모든 코드 변경 시, 상세 주석과 작업 로그 작성을 병행하기로 함.

### 2. 애플리케이션 기본 구조 구현 (`main.py`)

- **`MainWindow` 클래스:** PyQt5의 `QMainWindow`를 상속받아 메인 윈도우를 구성.
- **`OpenGLWidget` 클래스:** `QOpenGLWidget`을 상속받아 3D 그래픽을 렌더링할 영역을 구현하고, 메인 윈도우의 중앙 위젯으로 설정.
- **`OpenGLWidget`의 핵심 메서드:**
  - `initializeGL()`: OpenGL 상태 초기화 (배경색, 깊이 테스트 등).
  - `resizeGL()`: 윈도우 크기 변경에 따른 뷰포트 및 투영 행렬 조정.
  - `paintGL()`: 실제 렌더링(그리기)을 수행하는 메인 루프.
- **3D 좌표축 구현:**
  - `paintGL()` 내에서 `draw_axes()` 함수를 호출.
  - `draw_axes()`: 3D 공간의 기준점을 시각적으로 보여주기 위해, 원점에 R, G, B 색상의 X, Y, Z축을 그림. 이는 `gluLookAt`으로 설정된 카메라 시점에서 관찰됨.

### 3. UI 레이아웃 구조 설계

- `MainWindow`의 UI 설정을 `setupUI()` 메서드로 분리하여 코드 구조를 개선.
- **상단 툴바 (`QToolBar`):** 'Add Point', 'Create SOR' 등 핵심 기능을 빠르게 호출할 수 있는 액션(버튼)을 배치.
- **우측 컨트롤 패널 (`QDockWidget`):** 'Controls'라는 제목의 도킹 가능한 위젯을 추가. 내부에는 'Clear Points' 버튼 등 상세 조작을 위한 UI 요소들이 배치될 예정. 이 구조는 향후 확장성을 고려한 설계임.

### 4. 2D 편집 모드 전환 및 격자 표시

- 사용자 요구사항에 맞춰, **2D 평면에서 프로파일 곡선을 편집**하는 모드를 구현하기로 결정.
- **`view_mode` 상태 변수:** `OpenGLWidget`에 '2D' 또는 '3D' 상태를 저장하는 변수를 추가. 앱 시작 시 기본값은 '2D'.
- **조건부 렌더링:**
  - `resizeGL()`: `view_mode`가 '2D'이면 `glOrtho`를 사용한 2D 직교 투영을, '3D'이면 `gluPerspective`를 사용한 원근 투영을 설정하도록 수정.
  - `paintGL()`: `view_mode`가 '2D'이면 `draw_grid()`를, '3D'이면 `draw_axes()`를 호출하도록 분기.
- **`draw_grid()` 함수 구현:** 2D 편집의 기준이 될 수 있도록 배경에 회색 격자를 그리는 함수를 새로 추가.

### 5. 동적 격자 수정 및 마우스 입력 처리

- **동적 격자 생성:** 사용자 피드백을 반영하여, 창 크기가 변경될 때마다 `resizeGL`에서 계산된 투영 영역(`ortho_left` 등)에 맞춰 `draw_grid`가 격자를 동적으로 그리도록 수정. 이를 통해 창 크기를 조절해도 격자가 깨지지 않음.
- **마우스 입력 처리 (`mousePressEvent`):**
  - `OpenGLWidget`에 `mousePressEvent` 함수를 오버라이드하여 마우스 클릭 감지.
  - 2D 모드일 때, 클릭된 화면 좌표(픽셀)를 `glOrtho`로 설정된 월드 좌표계의 값으로 변환하는 로직 구현.
  - 변환된 (x, y) 좌표는 `self.points` 리스트에 저장되고, `self.update()`를 호출하여 화면 갱신.
- **점 그리기 및 삭제:**
  - `draw_points()`: `self.points` 리스트를 순회하며 노란색 점을 그리는 함수 추가. `paintGL`의 2D 모드에서 호출됨.
  - `clear_points()`: `self.points` 리스트를 비우는 함수 추가.
  - `MainWindow`의 'Clear Points' 버튼의 `clicked` 시그널을 `OpenGLWidget.clear_points` 함수에 연결하여 기능 활성화.

### 6. 2D/3D 뷰 모드 전환 기능 구현

- **`set_view_mode()` 메서드:** `OpenGLWidget`에 `set_view_mode(mode)` 메서드를 추가하여 `self.view_mode`를 변경하고, `resizeGL`을 호출하여 투영을 재설정하며, `update()`를 통해 화면을 갱신.
- **'Clear Points' 버튼 개선:** `clear_points()` 함수를 수정하여, 3D 뷰 모드에서 호출될 경우 점을 지우고 자동으로 2D 편집 모드로 전환되도록 함.
- **툴바 액션 연결:**
  - 'Add Point' 액션 클릭 시 `glWidget.set_view_mode('2D')` 호출.
  - 'Create SOR' 액션 클릭 시 `glWidget.set_view_mode('3D')` 호출.

### 7. 3D 뷰 렌더링 오류 수정 및 UI 로직 개선

- **3D 뷰 오류 수정 (최종):** 뷰 전환 시 렌더링이 즉시 갱신되지 않고 창 크기를 조절해야만 보이는 불안정한 상태의 원인을 분석하고 해결.
  - **원인:** 뷰 모드 전환 시 `set_view_mode`에서 `update()`만 호출할 경우, `paintGL`은 실행되지만 투영 행렬을 설정하는 `resizeGL`은 호출되지 않아 이전 모드의 투영 행렬이 그대로 사용되는 타이밍 문제.
  - **해결:** 투영 행렬 설정 로직을 `setupProjection` 함수로 분리. 이 함수를 `resizeGL` 뿐만 아니라 `paintGL` 함수 시작 부분에서도 매번 호출하도록 변경. 이로써 매 프레임마다 현재 뷰 모드에 맞는 투영 상태를 보장하여, 뷰 전환 시 즉시 올바른 화면이 렌더링되도록 문제를 완전히 해결.
- **UI 로직 개선:**
  - **역할 분리:** 'Clear Points' 버튼은 점 삭제 기능만 수행하도록 단순화. 뷰 전환은 상단 툴바('2D Edit', '3D View')가 전담하도록 역할을 명확히 분리.
  - **컨트롤 비활성화:** 3D 뷰 모드에서는 점 편집이 불가능하도록, `OpenGLWidget`에서 `viewModeChanged` 시그널을 보내면 `MainWindow`가 이를 받아 'Clear Points' 버튼을 비활성화하도록 시그널-슬롯 메커니즘을 구현.

### 8. 프로파일 곡선 시각화

- `draw_points` 함수를 수정하여, `GL_POINTS`로 점을 그리는 것에 더해 `GL_LINE_STRIP`을 사용하여 점들을 순서대로 잇는 선을 함께 그리도록 변경.
- 이를 통해 사용자는 자신이 만들고 있는 단면(프로파일)의 형태를 점을 찍는 과정에서 직관적으로 파악할 수 있게 됨.

### 9. SOR 모델 생성 준비: 단면 개수 UI 및 데이터 구조

- **단면 개수 UI 추가:** 컨트롤 패널에 'Number of Slices:' 레이블과 `QSpinBox`를 추가하여 사용자가 SOR 모델의 회전 단면 개수를 설정할 수 있도록 함. `QSpinBox`의 값 범위는 3에서 100으로 설정하고, 기본값은 30으로 지정.
- **`OpenGLWidget`에 데이터 구조 및 메서드 추가:**
  - `self.num_slices`: 회전 단면 개수를 저장하는 변수.
  - `self.sor_vertices`: 생성된 SOR 모델의 정점 데이터를 저장할 리스트.
  - `self.sor_faces`: 생성된 SOR 모델의 면 데이터를 저장할 리스트.
  - `set_num_slices(value)`: `QSpinBox`의 값 변경에 따라 `self.num_slices`를 업데이트하는 메서드.
  - `generate_sor_model()`: `self.points`를 기반으로 SOR 모델의 정점과 면 데이터를 생성하는 플레이스홀더 메서드.
  - `draw_sor_model()`: 생성된 SOR 모델을 그리는 플레이스홀더 메서드.
- **기능 연결:**
  - `set_view_mode`에서 '3D' 모드로 전환될 때, `self.points`가 존재하면 `generate_sor_model()`을 호출하여 모델 생성을 시도.
  - `paintGL`에서 '3D' 모드일 때, `self.sor_vertices`가 존재하면 `draw_sor_model()`을 호출하여 모델을 그리고, 그렇지 않으면 `draw_axes()`를 호출.
  - `clear_points` 함수가 호출될 때, `self.points`뿐만 아니라 `self.sor_vertices`와 `self.sor_faces`도 함께 초기화하여 모델 데이터를 리셋.
- **UI 활성화 제어:** `on_view_mode_changed` 슬롯에서 2D 모드일 때 `QSpinBox`를 활성화하고, 3D 모드일 때 비활성화하여 일관된 사용자 경험을 제공.

---

## 2025-11-19: 2D 편집 모드 및 UI/UX 최종 개선

사용자 피드백에 따라 2D 프로파일 편집 모드의 사용성과 시각적 완성도를 높이는 최종 수정 작업을 진행했습니다.

- **컨트롤 UI 통일성 강화:**
  - 사용자 피드백을 반영하여, 컨트롤 패널의 모든 섹션을 `QGroupBox`를 사용하여 명확하게 그룹화하고 시각적 일관성을 확보했습니다.
  - "Number of Slices"와 "Rotation Axis" 컨트롤들을 각각의 제목을 가진 `QGroupBox` 안에 배치하도록 `setupUI` 레이아웃 코드를 최종 리팩토링했습니다.
  - 각 `QGroupBox`의 상하에 `addSpacing(10)`을 추가하여 컨트롤 간 가독성을 높였습니다.
  - "Rotation Axis" 그룹박스 내의 라디오 버튼 순서를 X축, Y축 순으로 변경하고, 각 버튼에 `border-bottom` 스타일을 적용하여 2D 뷰의 축 색상(X-빨강, Y-초록)과 일치하는 색상 밑줄을 추가함으로써 직관성을 더욱 향상시켰습니다.
- **2D 렌더링 순서 조정 (Z-Fighting 해결):**
  - 2D 편집 모드에서 프로파일 선이 격자선에 가려지는 문제를 해결했습니다.
  - `draw_grid`에서 격자를 z = -0.1 깊이에, `draw_points`에서 점과 선을 z = 0.1 깊이에 그리도록 `glVertex3f`를 사용하여 렌더링 순서를 명확히 구분했습니다. 이로써 프로파일 곡선이 항상 격자 위에 표시됩니다.
- **UI 상태 관리 로직 단순화:** `on_view_mode_changed` 함수를 수정하여, 이제 두 `QGroupBox`의 활성화 상태만 제어하면 되도록 로직을 단순화하고 명확하게 만들었습니다. 이로써 2D/3D 모드 전환 시 모든 관련 컨트롤들이 일관되게 활성화/비활성화됩니다.

---

## 2025-11-19: 코드 모듈화 및 UI 기능 고도화

기존의 단일 `main.py` 파일 구조에서 벗어나, 유지보수성과 코드 가독성을 높이기 위해 대대적인 리팩토링 및 기능 추가를 진행했습니다.

### 1. 파일 구조 리팩토링 (모듈화)

- **목표:** UI(창) 관련 코드와 OpenGL 렌더링 코드를 분리하여 각 부분의 역할을 명확히 하고 독립적으로 개발할 수 있도록 함.
- **`main.py`:** 애플리케이션의 시작점(entry point) 역할만 수행하도록 코드를 최소화했습니다. 이제 `QApplication`을 생성하고 `ui_and_chang.py`에 정의된 `MainWindow`를 띄우는 역할만 담당합니다.
- **`ui_and_chang.py`:** `MainWindow` 클래스를 포함한 모든 PyQt5 UI 요소(툴바, 버튼, 컨트롤 패널 등)의 생성과 레이아웃, 그리고 UI 이벤트 처리(시그널-슬롯) 로직을 담당합니다.
- **`opengl_haeksim.py`:** `QOpenGLWidget`을 상속받는 `OpenGLWidget` 클래스가 위치하며, 모든 OpenGL 그래픽 처리(렌더링), 3D 데이터 관리(점, 모델 정점 등), 마우스 입력 처리 등 핵심 그래픽스 로직을 전담합니다.

### 2. 회전축 선택 UI 구현

- 컨트롤 패널에 "Rotation Axis" `QGroupBox`를 추가하여 SOR 모델 생성 시 사용할 회전축을 선택할 수 있는 기능을 구현했습니다.
- **UI 구성:** X축과 Y축을 선택할 수 있는 두 개의 `QRadioButton`으로 구성되며, SOR 모델의 일반적인 형태를 고려하여 Y축을 기본 선택 값으로 설정했습니다.
- **데이터 연동:** 라디오 버튼의 `toggled` 시그널은 `MainWindow`의 `_on_rotation_axis_changed` 슬롯에 연결됩니다. 이 슬롯은 `opengl_haeksim.py`의 `OpenGLWidget`에 있는 `set_rotation_axis(axis)` 메서드를 호출하여 선택된 축('X' 또는 'Y') 정보를 그래픽스 코어에 전달하고 저장합니다.

### 3. 실시간 좌표 리스트 UI 추가

- 사용자가 2D 편집 모드에서 찍은 점들의 좌표를 실시간으로 확인하고 관리할 수 있는 "Points List" UI를 `QGroupBox` 형태로 구현했습니다.
- **동적 UI 생성:** `QScrollArea`와 `QVBoxLayout`을 기반으로, 점이 추가되거나 삭제될 때마다 목록을 동적으로 다시 그립니다. 최신 점이 가장 위에 표시되도록 역순으로 목록을 생성하여 사용 편의성을 높였습니다.
- **시그널-슬롯 기반 실시간 업데이트:**
  - `OpenGLWidget`에서 점이 추가(`mousePressEvent`)되거나 삭제(`delete_point`, `clear_points`)될 때마다 `pointsChanged`라는 커스텀 시그널을 발생시킵니다.
  - `MainWindow`는 이 시그널을 `_update_point_list` 슬롯에 연결해두었습니다.
  - 시그널이 수신되면, `_update_point_list` 함수는 기존 목록을 모두 지우고 `OpenGLWidget`의 `points` 리스트에 있는 최신 데이터를 기반으로 UI를 새로 구성하여 실시간 동기화를 구현했습니다.
- **개별 점 삭제 기능:** 각 좌표 옆에 '×' 모양의 `QPushButton`을 추가했습니다. 이 버튼의 `clicked` 시그널은 특정 인덱스의 점을 삭제하는 `OpenGLWidget.delete_point(index)` 메서드와 `lambda`를 이용해 연결되어, 사용자가 원하는 점만 선택하여 삭제할 수 있습니다.

---

## 2025-11-20: 전체 코드 품질 개선 및 문서화

보고서 작성 및 향후 유지보수를 위해 프로젝트 전체 코드의 가독성과 품질을 높이는 대대적인 리팩토링 및 문서화 작업을 진행했습니다.

### 1. 목표

- **가독성 향상:** 모든 코드의 의도를 명확히 파악할 수 있도록 상세한 한글 주석과 docstring을 추가합니다.
- **구조 개선:** 각 파일과 함수가 단일 책임 원칙(SRP)에 가깝게 동작하도록 코드를 재구성하고, 중복을 제거하며, 일관된 컨벤션을 적용합니다.
- **유지보수성 확보:** 향후 기능 추가 및 수정이 용이한 구조를 만듭니다.

### 2. 주요 변경 사항

#### `main.py`

- **역할 명시:** 애플리케이션의 진입점(Entry Point)으로서의 역할이 명확히 드러나도록 파일 최상단에 상세한 docstring을 추가했습니다.
- **코드 설명 추가:** `QApplication` 생성, `MainWindow` 인스턴스화, `show()`, `exec_()` 등 각 실행 단계의 역할을 설명하는 인라인 주석을 보강했습니다.

#### `ui_and_chang.py`

- **핵심 구조 리팩토링:** 거대했던 `setupUI` 메서드를 `_create_toolbar`, `_create_controls_dock`, `_connect_signals` 등 기능별 private 헬퍼 메서드로 완벽히 분리하여, UI가 생성되는 과정을 체계적으로 파악할 수 있도록 구조를 개선했습니다.
- **컨트롤 생성 로직 분리:** `_create_controls_dock` 내부의 로직 또한 `_create_slices_group`, `_create_axis_group`, `_create_points_group`으로 세분화하여 각 UI 그룹박스의 생성 코드를 명확히 분리했습니다.
- **가독성 향상:**
  - 점 목록 UI를 업데이트하는 `_update_point_list` 내부의 레이아웃 초기화 로직을 별도의 `_clear_layout` 헬퍼 메서드로 추출하여 가독성을 높였습니다.
  - 미사용 `import` 구문을 제거하고, 내부용 메서드의 이름을 `_` 접두사로 통일하여 코드 컨벤션을 일관성 있게 맞췄습니다.
- **상세 주석:** 모든 메서드와 주요 로직에 상세한 docstring과 한글 주석을 추가하여, 각 UI 요소가 어떤 역할을 하고 어떻게 상호작용하는지 쉽게 이해할 수 있도록 문서화했습니다.

#### `opengl_haeksim.py`

- **문서화 강화:** 파일, 클래스, 모든 메서드 및 주요 속성에 상세한 한글 docstring과 주석을 추가하여, 그래픽스 코어의 동작 방식을 명확히 했습니다.
- **복잡한 로직 설명 추가:**
  - **좌표 변환:** `mousePressEvent`에서 Qt 화면 좌표를 OpenGL 월드 좌표로 변환하는 복잡한 과정에 대해, y축 변환부터 선형 보간에 이르는 각 단계를 설명하는 주석을 추가했습니다.
  - **Z-Fighting 해결:** `draw_grid`와 `draw_points`에서 2D 렌더링 시 격자와 프로파일 곡선이 겹치지 않도록 `z`값을 다르게 설정한 원리를 명시적으로 주석에 기록했습니다.
- **가독성 개선:**
  - `draw_axes`의 한 줄 짜리 코드를 축별로 여러 줄로 나누어 가독성을 크게 향상시켰습니다.
  - PyOpenGL의 `import *` 사용 관례에 대한 설명을 주석으로 추가하여, 코드의 배경지식을 보충했습니다.
- **구현 계획 구체화:** `generate_sor_model` 등 미구현된 함수의 `TODO` 주석을, 앞으로 구현해야 할 내용을 담아 더 구체적으로 수정했습니다.

이 작업을 통해 프로젝트의 모든 소스 코드는 높은 수준의 가독성과 체계적인 구조를 갖추게 되었으며, 다음 단계인 SOR 모델 생성 로직 구현을 위한 견고한 기반을 마련했습니다.

---

## 2025-11-28: SOR 모델 생성 로직 및 데이터 입출력 구현

드디어 프로젝트의 핵심인 SOR(Surface of Revolution) 모델 생성 알고리즘과, 생성된 모델을 파일로 저장하고 불러오는 기능을 구현했습니다.

### 1. 데이터 구조 설계 (.dat 파일 포맷)

- **목표:** 학부 과제 수준에 적합하고, 추후 미로 찾기 게임 등 다른 프로젝트에서 쉽게 파싱하여 사용할 수 있는 직관적인 파일 포맷 설계.
- **결정:** 텍스트 기반의 `.dat` 포맷을 정의함.
- **구조:**
  ```text
  <정점 개수>
  x y z
  ...
  <면 개수>
  <한 면의 점 개수(4)> v1 v2 v3 v4
  ...
  ```
  - 이 구조는 C언어의 `fscanf`나 Python의 `split` 함수로 별도의 복잡한 라이브러리 없이도 쉽게 읽을 수 있음.

### 2. SOR 모델 생성 알고리즘 구현 (`generate_sor_model`)

- **원리:** 2D 프로파일 곡선상의 점들을 지정된 축(Y축 또는 X축)을 기준으로 360도 회전시켜 3D 정점들을 생성.
- **구현 상세:**
  1.  **회전 각도 계산:** `360도 / 단면 개수(num_slices)`로 각 단면 사이의 각도(`angle_step`)를 계산.
  2.  **정점 생성 (Vertices):** 이중 루프(`단면` -> `프로파일 점`)를 돌며 삼각함수(`sin`, `cos`)를 이용해 회전된 좌표를 계산.
      - **Y축 회전:** $x' = x \cos\theta, z' = -x \sin\theta, y' = y$
      - **X축 회전:** $y' = y \cos\theta, z' = y \sin\theta, x' = x$
  3.  **면 생성 (Faces):** 인접한 두 단면과 두 점을 연결하여 사각형(Quad) 면을 구성.
      - 인덱스 계산을 통해 `(현재 단면, 현재 점)`, `(현재 단면, 다음 점)`, `(다음 단면, 다음 점)`, `(다음 단면, 현재 점)` 순서로 연결.
      - 마지막 단면은 첫 번째 단면과 연결하여 닫힌 입체를 형성.

### 3. 렌더링 및 시각화 (`draw_sor_model`)

- **방식:** `GL_QUADS`를 사용하여 생성된 사각형 면들을 렌더링.
- **시각적 개선:**
  - **색상:** 모델을 밝은 청록색(`0.0, 0.8, 0.8`)으로 칠하여 시인성 확보.
  - **와이어프레임 오버레이:** 면 위에 흰색 선으로 와이어프레임을 덧그려(`glPolygonMode(..., GL_LINE)`), 모델의 구조와 폴리곤 구성을 명확히 볼 수 있도록 함.

### 4. 파일 입출력 기능 (`save_model`, `load_model`)

- **저장:** 현재 생성된 `sor_vertices`와 `sor_faces` 데이터를 앞서 정의한 `.dat` 포맷에 맞춰 텍스트 파일로 저장.
- **불러오기:** `.dat` 파일을 읽어 파싱한 뒤, 내부 데이터를 갱신하고 즉시 3D 뷰로 전환하여 확인 가능하도록 구현. 이는 저장 기능의 검증 도구로도 활용됨.

### 5. UI 통합

- 툴바에 'Save Model', 'Load Model' 액션을 추가하고 `QFileDialog`를 연결하여 사용자가 직관적으로 파일을 관리할 수 있도록 함.
- 모델 데이터가 없는 상태에서 저장을 시도할 경우 경고 메시지(`QMessageBox`)를 띄워 예외 처리.

---

## 2025-11-28: 기능 고도화 (파일 포맷 개선, 스냅 기능, 3D 뷰 수정)

사용자 피드백을 반영하여 프로그램의 완성도를 높이는 추가 작업을 진행했습니다.

### 1. 파일 포맷 및 입출력 기능 개선

- **문제점:** 기존 `.dat` 포맷은 3D 모델 데이터만 저장하여, 불러오기 시 2D 편집 상태(점 위치, 설정값)가 복원되지 않아 수정이 불가능했음.
- **해결:** 파일 포맷을 확장하여 편집 상태를 완벽히 복원할 수 있도록 개선함.
- **개선된 포맷 구조:**
  ```text
  <단면 개수>
  <회전축 (0:X, 1:Y)>
  <2D 점 개수>
  x y
  ...
  <3D 정점 개수>
  x y z
  ...
  <면 개수>
  ...
  ```
- **UI 동기화:** 모델을 불러올 때, 파일에 저장된 `단면 개수`와 `회전축` 정보를 읽어 UI 컨트롤(`QSpinBox`, `QRadioButton`)에 즉시 반영되도록 구현.

### 2. 2D 편집 편의성 향상 (Snap 기능)

- **기능:** 사용자가 점을 찍을 때, 기존에 찍은 점 근처(거리 0.3 이내)를 클릭하면 자동으로 해당 점의 위치로 좌표가 보정(Snap)되는 기능을 추가.
- **효과:** 이를 통해 시작점과 끝점을 정확히 일치시켜 '닫힌 도형(Closed Loop)'을 손쉽게 그릴 수 있게 됨.

### 3. 3D 뷰 시점 수정

- **문제점:** 3D 뷰 전환 시 모델이 너무 크게 보이거나 화면을 벗어나서 전체 형태를 파악하기 어려웠음.
- **해결:** `gluLookAt`의 카메라 위치(Eye Position)를 `(3, 3, 5)`에서 `(10, 10, 20)`으로 조정하여, 더 넓은 시야를 확보하고 모델 전체가 화면에 잘 들어오도록 개선함.

---

## 2025-11-28: 2D 편집 기능 대폭 강화 (다중 경로, 드래그 이동)

사용자가 더 복잡하고 정교한 모델을 쉽고 직관적으로 만들 수 있도록 2D 편집 기능을 대대적으로 업그레이드했습니다.

### 1. 다중 경로(Multi-Path) 지원

- **기존 한계:** 하나의 연결된 선(Path)만 그릴 수 있어, 서로 떨어진 물체(예: 행성과 고리)를 표현할 수 없었음.
- **개선:**
  - 내부 데이터 구조를 `List of Points`에서 `List of Lists of Points`로 변경하여 여러 개의 독립적인 경로를 관리하도록 함.
  - **사용법:** 도형을 그리다가 시작점을 다시 클릭하여 '닫힌 도형'을 완성하면, 다음 클릭부터는 자동으로 새로운 도형(Path)이 시작됨.
  - **렌더링:** `generate_sor_model` 함수가 모든 경로를 순회하며 각각에 대한 3D 모델을 생성하고 합쳐서 렌더링함.

### 2. 점 드래그 이동 (Point Dragging)

- **기능:** 이미 찍힌 점을 마우스로 드래그하여 위치를 수정할 수 있는 기능 추가.
- **구현:**
  - `mousePressEvent`: 클릭한 위치가 기존 점 근처인지 확인(Hit Test). 맞다면 해당 점을 '드래그 대상'으로 설정.
  - `mouseMoveEvent`: 드래그 중인 점의 좌표를 마우스 위치에 따라 실시간으로 업데이트하고 화면을 갱신.
  - `mouseReleaseEvent`: 드래그 종료.

### 3. 파일 포맷 업데이트 (v3)

- **변경:** 다중 경로 데이터를 저장하기 위해 파일 포맷을 다시 한번 확장함.
- **구조:**
  ```text
  ...
  <경로 개수>
  <경로 1 점 개수>
  x y
  ...
  <경로 2 점 개수>
  ...
  ```
- 기존 단일 경로 방식에서 유연하게 확장된 구조로, 복잡한 모델 데이터도 손실 없이 저장하고 불러올 수 있음.

### 4. 버그 수정 (3D 뷰 크래시)

- **증상:** 2D 편집 후 3D 뷰로 전환 시 프로그램이 강제 종료되는 현상 발생.
- **원인:** `set_view_mode` 함수에서 이미 삭제된 `self.points` 변수를 참조하려고 하여 `AttributeError`가 발생함. (리팩토링 과정에서의 실수)
- **조치:**
  - `self.points` 참조 코드를 `self.paths`를 확인하는 로직으로 수정.
  - `paintGL` 및 `generate_sor_model` 함수에 `try-except` 블록을 추가하여, 예외 발생 시 프로그램이 종료되지 않고 에러 로그를 출력하도록 안전장치 마련.

### 5. 도형 닫기 방식 개선 (Explicit Path Closing)

- **문제점:** 기존의 '시작점 클릭하여 닫기' 방식은 점을 수정(드래그)하다가 실수로 도형이 열리거나, 의도치 않게 닫히는 등 사용성이 떨어짐.
- **해결:**
  - **'Close Path' 버튼 추가:** 명시적인 버튼 클릭으로만 도형을 닫도록 변경.
  - **데이터 구조 변경:** 각 경로마다 `closed` 플래그를 두어 닫힘 상태를 관리.
  - **효과:** 닫힌 도형의 점을 자유롭게 드래그해도 연결이 유지되며, 편집이 훨씬 직관적으로 변함.
- **파일 포맷 업데이트 (v4):** `closed` 상태를 저장하기 위해 포맷을 확장함.
- **UI 수정:** 'Clear All Points' 버튼이 중복으로 생성되던 문제를 수정하여 하단에 하나만 유지하도록 함.
- **제약 조건 완화:** SOR 모델링의 특성을 고려하여, 점이 2개만 있어도(선분) 도형을 닫을 수 있도록 허용함. (기존 3개 이상 -> 2개 이상)

---

## 2025-11-28: 2D 편집 기능 대폭 강화 (다중 경로, 드래그 이동)

사용자가 더 복잡하고 정교한 모델을 쉽고 직관적으로 만들 수 있도록 2D 편집 기능을 대대적으로 업그레이드했습니다.

### 1. 다중 경로(Multi-Path) 지원

- **기존 한계:** 하나의 연결된 선(Path)만 그릴 수 있어, 서로 떨어진 물체(예: 행성과 고리)를 표현할 수 없었음.
- **개선:**
  - 내부 데이터 구조를 `List of Points`에서 `List of Lists of Points`로 변경하여 여러 개의 독립적인 경로를 관리하도록 함.
  - **사용법:** 도형을 그리다가 시작점을 다시 클릭하여 '닫힌 도형'을 완성하면, 다음 클릭부터는 자동으로 새로운 도형(Path)이 시작됨.
  - **렌더링:** `generate_sor_model` 함수가 모든 경로를 순회하며 각각에 대한 3D 모델을 생성하고 합쳐서 렌더링함.

### 2. 점 드래그 이동 (Point Dragging)

- **기능:** 이미 찍힌 점을 마우스로 드래그하여 위치를 수정할 수 있는 기능 추가.
- **구현:**
  - `mousePressEvent`: 클릭한 위치가 기존 점 근처인지 확인(Hit Test). 맞다면 해당 점을 '드래그 대상'으로 설정.
  - `mouseMoveEvent`: 드래그 중인 점의 좌표를 마우스 위치에 따라 실시간으로 업데이트하고 화면을 갱신.
  - `mouseReleaseEvent`: 드래그 종료.

### 3. 파일 포맷 업데이트 (v3)

- **변경:** 다중 경로 데이터를 저장하기 위해 파일 포맷을 다시 한번 확장함.
- **구조:**
  ```text
  ...
  <경로 개수>
  <경로 1 점 개수>
  x y
  ...
  <경로 2 점 개수>
  ...
  ```
- 기존 단일 경로 방식에서 유연하게 확장된 구조로, 복잡한 모델 데이터도 손실 없이 저장하고 불러올 수 있음.

### 4. 버그 수정 (3D 뷰 크래시)

- **증상:** 2D 편집 후 3D 뷰로 전환 시 프로그램이 강제 종료되는 현상 발생.
- **원인:** `set_view_mode` 함수에서 이미 삭제된 `self.points` 변수를 참조하려고 하여 `AttributeError`가 발생함. (리팩토링 과정에서의 실수)
- **조치:**
  - `self.points` 참조 코드를 `self.paths`를 확인하는 로직으로 수정.
  - `paintGL` 및 `generate_sor_model` 함수에 `try-except` 블록을 추가하여, 예외 발생 시 프로그램이 종료되지 않고 에러 로그를 출력하도록 안전장치 마련.

### 5. 도형 닫기 방식 개선 (Explicit Path Closing)

- **문제점:** 기존의 '시작점 클릭하여 닫기' 방식은 점을 수정(드래그)하다가 실수로 도형이 열리거나, 의도치 않게 닫히는 등 사용성이 떨어짐.
- **해결:**
  - **'Close Path' 버튼 추가:** 명시적인 버튼 클릭으로만 도형을 닫도록 변경.
  - **데이터 구조 변경:** 각 경로마다 `closed` 플래그를 두어 닫힘 상태를 관리.
  - **효과:** 닫힌 도형의 점을 자유롭게 드래그해도 연결이 유지되며, 편집이 훨씬 직관적으로 변함.
- **파일 포맷 업데이트 (v4):** `closed` 상태를 저장하기 위해 포맷을 확장함.
- **UI 수정:** 'Clear All Points' 버튼이 중복으로 생성되던 문제를 수정하여 하단에 하나만 유지하도록 함.
- **제약 조건 완화:** SOR 모델링의 특성을 고려하여, 점이 2개만 있어도(선분) 도형을 닫을 수 있도록 허용함. (기존 3개 이상 -> 2개 이상)

---

## 2025-11-28: 3D 렌더링 고도화 및 최종 폴리싱

프로젝트의 시각적 완성도를 높이기 위해 3D 렌더링 기능을 대폭 강화하고, UI/UX를 다듬어 최종 결과물을 완성했습니다.

### 1. 3D 렌더링 모드 및 조명 구현

- **다양한 렌더링 모드 지원:**
  - **Wireframe:** 모델의 구조를 파악할 수 있는 선 렌더링.
  - **Solid:** 조명 없이 단색으로 면을 채우는 모드.
  - **Flat Shading:** 각 면의 법선 벡터를 사용하여 각진 느낌을 주는 쉐이딩.
  - **Gouraud Shading:** 정점 법선 벡터를 보간하여 부드러운 곡면을 표현하는 쉐이딩.
- **조명 시스템 개선 (Dual Lighting):**
  - 기존의 단일 조명(Key Light)만으로는 그림자 부분이 너무 어둡고 평면적으로 보이는 문제가 있었음.
  - **Fill Light 추가:** 주 조명의 반대편(좌측 상단 후면)에 약한 보조 조명을 배치하여, 그림자 영역의 디테일을 살리고 입체감을 극대화함.
- **재질(Material) 설정:** `GL_COLOR_MATERIAL`을 활성화하여 `glColor` 함수만으로도 재질의 확산(Diffuse) 및 주변(Ambient) 반사 속성이 적용되도록 구현.

### 2. UI/UX 폴리싱

- **컨트롤 패널 분리:** 뷰 모드(2D/3D)에 따라 관련 없는 컨트롤은 숨기고 필요한 컨트롤만 보여주도록 UI를 동적으로 구성하여 복잡도를 낮춤.
- **디자인 일관성 확보:**
  - 2D와 3D 컨트롤 패널의 여백(Margin)과 간격(Spacing)을 통일하여 모드 전환 시 시각적 위화감을 제거.
  - 모든 컨트롤을 그룹박스로 감싸 기능을 명확히 구분.
- **사용자 편의 기능:**
  - **Wireframe Toggle:** 렌더링 모드와 상관없이 와이어프레임을 덧그려 볼 수 있는 체크박스 추가.
  - **Color Picker:** 모델의 색상을 자유롭게 변경할 수 있는 기능 추가.
  - **Projection Mode:** 원근 투영(Perspective)과 직교 투영(Orthographic)을 선택할 수 있는 기능 추가.

### 3. 데이터 가이드 작성

- 협업을 위해 `.dat` 파일 포맷(v5)을 상세히 설명하는 `data_guide.md` 문서를 작성하여 프로젝트 루트에 저장함.

---

## 2025-12-04: 사이드바 UI 고도화 및 동적 테마 시스템 구현

사용자 경험(UX)과 시각적 완성도를 높이기 위해 사이드바 UI를 전면 개편하고, 시스템 테마(Light/Dark Mode)에 실시간으로 반응하는 동적 테마 시스템을 구현했습니다.

### 1. 사이드바 UI 정밀 제어 (Sidebar Refinement)

- **문제점:** 기존 `QListWidget`의 기본 스타일로는 아이콘의 정렬, 간격, 선택 효과 등을 세밀하게 제어하기 어려웠음.
- **해결:**
  - **레이아웃 최적화:** `IconMode`를 사용하되, `GridSize`와 `IconSize`를 정밀하게 조정하여 아이콘이 사이드바 중앙에 완벽하게 정렬되도록 함.
  - **시각적 구분:** 사이드바와 콘텐츠 영역 사이에 1px 두께의 경계선(`border-right`)을 추가하여 영역을 명확히 구분함.
  - **불필요한 요소 제거:** 스크롤바, 포커스 아웃라인 등을 제거하여 깔끔한 앱 스타일의 룩앤필을 구현함.

### 2. 동적 테마 시스템 (Dynamic Theme Switching)

- **목표:** macOS의 라이트/다크 모드 전환에 맞춰 애플리케이션의 색상 테마가 즉시 변경되도록 함.
- **구현:**
  - **테마 감지:** `QApplication.palette().color(QPalette.Window).lightness()`를 확인하여 현재 시스템이 다크 모드인지 판별함.
  - **이벤트 리스너:** `changeEvent` 메서드에서 `QEvent.ApplicationPaletteChange` 이벤트를 감지하여, 시스템 테마 변경 시 즉시 스타일 업데이트 함수(`_update_styles`)를 호출함.
  - **동적 스타일링:** 테마에 따라 사이드바 배경, 아이콘 색상, 선택 강조 색상, 경계선 색상 변수를 실시간으로 교체함.

### 3. 아이콘 틴팅 및 선택 효과 (Icon Tinting & Selection)

- **문제점:**
  - `QListWidget`의 기본 선택 효과는 아이콘 전체를 파란색으로 덮어버려(Tint), 아이콘의 형태를 알아보기 힘들고 미적으로도 좋지 않았음.
  - 라이트 모드에서는 흰색 아이콘이, 다크 모드에서는 검은색 아이콘이 잘 보이지 않는 가시성 문제가 존재함.
- **해결 (QIcon Mode 활용):**
  - **동적 아이콘 생성:** `_create_themed_icon` 함수를 구현하여, 테마와 선택 상태에 맞는 `QIcon`을 프로그래밍 방식으로 생성함.
  - **색상 로직:**
    - **Normal 상태:** 다크 모드에서는 흰색, 라이트 모드에서는 진한 회색(#333333)으로 틴팅.
    - **Selected 상태:** 다크 모드에서는 흰색, 라이트 모드에서도 진한 회색(#333333)을 유지하여 가독성 확보. (배경색으로 선택 상태 구분)
  - **기술적 구현:** `QPainter.CompositionMode_SourceIn`을 사용하여 원본 아이콘의 불투명 영역에만 원하는 색상을 덧입히는 틴팅 기법을 적용함.

---

## 2025-12-04: 미로 게임 타이틀 화면 구현

미로 게임의 시작점인 타이틀 화면을 구현하고, 다양한 게임 모드를 선택할 수 있는 메뉴 UI를 구성했습니다.

### 1. 타이틀 화면 구조 (Title Screen Structure)

- **`QStackedWidget` 도입:** 타이틀 화면(Page 0)과 게임 화면(Page 1)을 분리하여 관리하기 위해 스택 위젯을 사용했습니다. 이를 통해 화면 전환이 매끄럽게 이루어집니다.
- **타이틀 이미지:** 텍스트 대신 이미지를 사용하여 타이틀을 표시하도록 `QLabel`과 `QPixmap`을 활용했습니다. (`assets/maze_title.png`)

### 2. 게임 모드 메뉴 (Game Mode Menu)

사용자가 선택할 수 있는 4가지 게임 모드 버튼을 구현했습니다.

- **Story Mode:** 스토리 기반 진행 (추후 구현 예정).
- **Stage 1 ~ 3:** 난이도별 스테이지.
- **Custom Mode (내 마음대로):** 사용자가 직접 미로의 환경을 설정할 수 있는 모드.

### 3. 커스텀 게임 설정 UI (Custom Game Setup)

'내 마음대로' 모드 선택 시 나타나는 설정 패널을 구현했습니다.

- **UI 구성:** `QGroupBox` 내에 미로 크기(`QSpinBox`), 안개 효과(`QCheckBox`), 날씨(`QComboBox`), 텍스처 테마(`QComboBox`) 설정 컨트롤을 배치했습니다.
- **동적 표시:** 평소에는 숨겨져 있다가 'Custom Mode' 버튼을 클릭하면 토글(Toggle) 방식으로 나타나도록 구현하여 UI 공간을 효율적으로 사용했습니다.

### 4. 레이아웃 고도화 (Layout Refinement)

사용자 피드백을 반영하여 타이틀 화면의 레이아웃을 좌우 분할 구조로 개선했습니다.

- **좌측 패널 (스토리 모드):** '스토리 읽기' 및 '스테이지 1~3' 버튼을 배치하여 정해진 흐름대로 게임을 즐길 수 있도록 구성했습니다.
- **우측 패널 (내 맘대로 모드):** 커스텀 설정 컨트롤을 항상 표시되도록 변경하여, 사용자가 설정을 직관적으로 확인하고 바로 게임을 시작할 수 있도록 접근성을 높였습니다.
- **타이틀 이미지 최적화:** 가로로 긴 형태의 투명 배경 PNG 이미지를 고려하여 `scaled` 메서드 호출 시 가로 폭을 800px로 늘리고 비율을 유지하도록 조정했습니다.

### 5. 스타일 표준화 및 영문화 (Style Standardization & Localization)

프로젝트의 핵심인 OpenGL 구현에 집중하기 위해 UI 스타일을 간소화하고, 국제화(Global) 표준에 맞춰 언어를 영어로 통일했습니다.

- **기본 스타일 복귀:** 버튼 및 그룹박스에 적용했던 커스텀 스타일시트(색상, 테두리 등)를 제거하여, OS 기본 테마(Native Look & Feel)를 따르도록 했습니다. 이는 3D 모델러 파트와의 일관성을 유지하기 위함입니다.
- **영문 UI 적용:** 모든 메뉴, 버튼, 라벨의 텍스트를 한글에서 영어로 변경했습니다. (예: "스토리 모드" -> "Story Mode", "내 맘대로 모드" -> "Custom Mode")
- **버튼 높이 조정:** 기본 스타일을 유지하면서 클릭 영역을 확보하기 위해 `setMinimumHeight(40)`을 적용하여 버튼 높이를 키웠습니다. (Start Game 버튼은 50px로 강조)

### 6. UI 구조 개선 및 메뉴바 도입 (UI Refinement & Menu Bar)

사용자 피드백을 반영하여 UI의 가독성을 높이고, 3D 모델러와 유사한 사용성을 제공하기 위해 메뉴바를 도입했습니다.

- **구분선 및 그룹화:** 각 섹션(스토리/커스텀) 내에 구분선(`QFrame.HLine`)을 추가하고, 커스텀 설정 항목들을 'Maze Settings', 'Environment' 등 하위 그룹박스로 묶어 시각적 위계를 명확히 했습니다.
- **초기 화면 변경:** 프로그램 실행 시 미로 게임 화면이 먼저 나타나도록 변경하고, 사이드바 사용을 유도하기 위해 "← Click here to use 3D Modeler" 안내 문구를 추가했습니다.
- **메뉴바 구현:** `MiroWindow`에도 상단 메뉴바를 추가하여 'View' (1인칭/3인칭 시점) 및 'Minimap' (켜기/끄기) 제어 기능을 탑재했습니다. 이는 3D 모델러의 인터페이스와 통일성을 갖추기 위함입니다.
  - **이슈 해결:** `QMenuBar`가 정상적으로 표시되지 않는 문제를 해결하기 위해 `MiroWindow`의 상속 클래스를 `QWidget`에서 `QMainWindow`로 변경하고, `setCentralWidget`을 사용하여 레이아웃 구조를 표준화했습니다.
  - **디자인 개선:** 사용자의 요청에 따라 평면적인 메뉴바 대신 `QToolBar`를 적용하여, 3D 모델러와 동일한 Native Look(그라데이션, 패딩 등)을 제공하도록 개선했습니다. 'View Mode'는 드롭다운 버튼으로, 'Minimap'은 토글 버튼으로 구현했습니다.
  - **기능 확장:** 툴바를 이동 가능(`setMovable(True)`)하도록 설정하고, 가장 좌측에 'Abort and Return to Title' 버튼을 추가하여 게임 중 언제든지 타이틀로 복귀할 수 있는 편의 기능을 제공했습니다.
- **크레딧 섹션:** 타이틀 화면 하단에 개발자 정보를 표시하는 크레딧 텍스트(`QLabel`)를 추가하여 프로젝트의 완성도를 높였습니다.
- **코드 정리:** `miro_ui_and_chang.py`의 모든 주석을 한글로 통일하고, 변수 및 함수 명명 규칙을 점검하여 코드의 가독성과 유지보수성을 확보했습니다.
- **크로스 플랫폼 호환성 개선:**
  - **Windows UI 수정:** Windows 환경에서 폰트 렌더링 차이로 인한 UI 잘림 현상을 해결하기 위해 커스텀 모드 패널의 너비를 확장하고, 툴바 버튼에 패딩을 추가하여 화살표 아이콘 공간을 확보했습니다.
  - **OpenGL 안정성 강화:** Windows 환경에서 3D 뷰 전환 시 발생하는 크래시 문제를 해결하기 위해, 정점 데이터 생성 시 명시적인 `float` 형변환을 적용하고 `glPolygonOffset` 사용 시 예외 처리를 추가하여 안정성을 높였습니다.
- **크로스 플랫폼 호환성 개선 (2차):**
  - **UI 심미성 개선:** 플랫폼 간 일관된 디자인을 위해 'View Mode' 드롭다운의 화살표 아이콘을 제거(`menu-indicator: none`)하고, 패널 너비를 고정값 대신 동적(`QSizePolicy.Expanding`)으로 설정하여 콘텐츠에 유연하게 대응하도록 개선했습니다. 또한, 패널 간 간격(`Spacing: 40`)과 좌우 여백(`Margins: 50`)을 추가하여 UI가 화면 가장자리에 붙는 현상을 방지했습니다.
  - **OpenGL 크래시 심층 디버깅:** 데이터 생성 및 렌더링 과정에서 발생할 수 있는 NaN(Not a Number) 및 무한대(Inf) 값에 대한 검증 로직을 추가하고, 인덱스 범위를 벗어나는 참조를 방지하는 안전장치를 `calculate_normals`와 `draw_model`에 적용했습니다.
- **최종 정리 및 UI 폴리싱:**
  - **디버그 코드 제거:** 문제 해결이 확인됨에 따라 `modeler_opengl.py`에 추가했던 임시 디버그 로그(`print`)를 모두 제거하여 코드를 정리했습니다.
  - **3D 뷰 오버레이 개선:** 3D 모델러 화면 우측 상단의 안내 문구 스타일을 미로 게임 타이틀의 힌트 문구와 유사하게(밝은 회색, 이탤릭체, Arial 폰트) 변경하고, 여백을 조정하여 Windows 환경에서도 깔끔하게 보이도록 개선했습니다.
  - **주석 정리:** `modeler_opengl.py`의 모든 주석을 한글로 통일하고, 임시 주석을 제거하여 코드 가독성을 높였습니다.

이로써 미로 게임의 진입점이 완성되었으며, 향후 각 모드별 게임 로직을 연결할 준비가 되었습니다.
