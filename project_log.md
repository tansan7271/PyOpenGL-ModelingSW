# Gemini와 함께하는 PyOpenGL 모델러 개발 로그

이 파일은 Computer Graphics 기말 프로젝트(SOR 모델러) 개발 과정을 기록하기 위해 생성되었습니다.
Gemini와의 대화 내용, 주요 결정 사항, 작업 흐름 등을 기록하여 언제든 개발 맥락을 다시 파악할 수 있도록 합니다.

---

## 메타: 이 로그 파일의 사용법

- 이 파일은 Gemini와의 대화 맥락과 주요 결정 사항을 기록하기 위해 사용됩니다.
- 대화 세션이 종료되거나 다시 시작될 때, Gemini가 이 파일을 참조하여 이전 작업 내용을 파악하고 일관된 지원을 제공할 수 있도록 합니다.
- 사용자가 "지금까지 나눈 대화를 맥락 파일에 업데이트해줘"라고 요청하면, Gemini는 현재까지의 대화 요약을 이 파일에 추가합니다.

---

## 프로젝트 시작 및 초기 설정

### 1. 프로젝트 목표 정의

- **사용자 요청:** 컴퓨터 그래픽스 기말 과제 수행.
- **과제 내용:**
  1. PyOpenGL을 이용한 SOR(Surface of Revolution) 3D 모델러 개발.
  2. 생성된 모델을 활용하는 미로 탐색 게임 개발.
  3. 관련 내용 보고서 작성.
- **담당 파트:** SOR 3D 모델러 개발.
- **참고 자료:** `CG_FinalProject.pdf`

### 2. 주요 요구사항 및 제약조건 분석

- **기술 스택:** Python, PyOpenGL.
- **결과물:** `.exe` 실행 파일, 소스 코드, `.dat` 모델 파일.
- **제약 조건:**
  - 생성형 AI 사용은 가능하나, 코드에 대한 완벽한 이해 필요.
  - 보고서 및 소스 코드의 유사도 검사(카피킬러) 예정. 오픈소스 활용 시 독창적인 변형 필요.

### 3. 작업 환경 설정

- **사용자 요청:** 프로젝트 진행 내용 추적을 위한 기록 파일 생성 요청.
- **생성된 파일:**
  1. `project_log.md`: 대화 및 작업 흐름 기록용.
  2. `report_notes.md`: 최종 보고서 작성을 위한 자료 수집용.
- **결정:** 이 파일들을 지속적으로 업데이트하며 프로젝트를 진행하기로 함.

---

## 기술 스택 논의 및 확정

### 1. GUI 라이브러리 논의

- **PyQt 제안:** 초기 제안으로, PyOpenGL과 호환성이 좋고 기능이 강력한 PyQt를 제안함.
- **macOS 및 .exe 빌드 우려:** 사용자는 macOS 환경에서 개발하며, 최종 제출물은 Windows용 `.exe`여야 한다는 점을 지적.
  - **해결책:** 개발은 macOS에서 진행하고, 최종 패키징 단계만 Windows 환경에서 `pyinstaller`를 사용하는 것으로 전략 수립.
- **PyQt와 표절률 우려:** 공통 프레임워크 사용 시 표절률 문제를 걱정.
  - **결론:** 라이브러리(도구) 사용 자체는 표절이 아니며, 직접 작성하는 애플리케이션 로직의 독창성이 중요함을 확인함.
- **대안 1 (Pure OpenGL UI):** PyQt 없이 OpenGL의 기본 입력 함수만으로 UI를 구현하는 방안을 논의. (장점: 독창성, 학습 효과 / 단점: 개발 시간, 복잡성)
- **대안 2 (Electron):** 팀원의 제안으로 Electron 프레임워크 사용 가능성을 검토.
  - **결론:** Python-OpenGL과의 연동 복잡성, 성능 문제, 프로젝트의 핵심을 벗어나는 과한 구조 등의 이유로 부적합하다고 판단.

### 2. 최종 결정

- 논의 끝에, 최종적으로 **PyQt5**를 사용하여 SOR 모델러를 개발하기로 확정함.

---

## 2025-11-18: 기본 구조 설정 및 3D 뷰포트 구현

### 1. 개발 원칙 수립

- **사용자 요청:** 보고서 작성 및 코드의 독창성 확보를 위해, 코드에 상세한 주석을 추가하고 `project_log.md`에 작업 내역을 구체적으로 기록할 것을 요청함.
- **결정:** 향후 모든 코드 변경 시, 상세 주석과 작업 로그 작성을 병행하기로 함.

### 2. 애플리케이션 기본 구조 구현 (`main.py`)

- **`MainWindow` 클래스:** PyQt5의 `QMainWindow`를 상속받아 메인 윈도우를 구성.
- **`OpenGLWidget` 클래스:** `QOpenGLWidget`을 상속받아 3D 그래픽을 렌더링할 영역을 구현하고, 메인 윈도우의 중앙 위젯으로 설정.
- **`OpenGLWidget`의 핵심 메서드:**
  - `initializeGL()`: OpenGL 상태 초기화 (배경색, 깊이 테스트 등).
  - `resizeGL()`: 윈도우 크기 변경에 따른 뷰포트 및 투영 행렬 조정.
  - `paintGL()`: 실제 렌더링(그리기)을 수행하는 메인 루프.
- **3D 좌표축 구현:**
  - `paintGL()` 내에서 `draw_axes()` 함수를 호출.
  - `draw_axes()`: 3D 공간의 기준점을 시각적으로 보여주기 위해, 원점에 R, G, B 색상의 X, Y, Z축을 그림. 이는 `gluLookAt`으로 설정된 카메라 시점에서 관찰됨.

### 3. UI 레이아웃 구조 설계

- `MainWindow`의 UI 설정을 `setupUI()` 메서드로 분리하여 코드 구조를 개선.
- **상단 툴바 (`QToolBar`):** 'Add Point', 'Create SOR' 등 핵심 기능을 빠르게 호출할 수 있는 액션(버튼)을 배치.
- **우측 컨트롤 패널 (`QDockWidget`):** 'Controls'라는 제목의 도킹 가능한 위젯을 추가. 내부에는 'Clear Points' 버튼 등 상세 조작을 위한 UI 요소들이 배치될 예정. 이 구조는 향후 확장성을 고려한 설계임.

### 4. 2D 편집 모드 전환 및 격자 표시

- 사용자 요구사항에 맞춰, **2D 평면에서 프로파일 곡선을 편집**하는 모드를 구현하기로 결정.
- **`view_mode` 상태 변수:** `OpenGLWidget`에 '2D' 또는 '3D' 상태를 저장하는 변수를 추가. 앱 시작 시 기본값은 '2D'.
- **조건부 렌더링:**
  - `resizeGL()`: `view_mode`가 '2D'이면 `glOrtho`를 사용한 2D 직교 투영을, '3D'이면 `gluPerspective`를 사용한 원근 투영을 설정하도록 수정.
  - `paintGL()`: `view_mode`가 '2D'이면 `draw_grid()`를, '3D'이면 `draw_axes()`를 호출하도록 분기.
- **`draw_grid()` 함수 구현:** 2D 편집의 기준이 될 수 있도록 배경에 회색 격자를 그리는 함수를 새로 추가.

### 5. 동적 격자 수정 및 마우스 입력 처리

- **동적 격자 생성:** 사용자 피드백을 반영하여, 창 크기가 변경될 때마다 `resizeGL`에서 계산된 투영 영역(`ortho_left` 등)에 맞춰 `draw_grid`가 격자를 동적으로 그리도록 수정. 이를 통해 창 크기를 조절해도 격자가 깨지지 않음.
- **마우스 입력 처리 (`mousePressEvent`):**
  - `OpenGLWidget`에 `mousePressEvent` 함수를 오버라이드하여 마우스 클릭 감지.
  - 2D 모드일 때, 클릭된 화면 좌표(픽셀)를 `glOrtho`로 설정된 월드 좌표계의 값으로 변환하는 로직 구현.
  - 변환된 (x, y) 좌표는 `self.points` 리스트에 저장되고, `self.update()`를 호출하여 화면 갱신.
- **점 그리기 및 삭제:**
  - `draw_points()`: `self.points` 리스트를 순회하며 노란색 점을 그리는 함수 추가. `paintGL`의 2D 모드에서 호출됨.
  - `clear_points()`: `self.points` 리스트를 비우는 함수 추가.
  - `MainWindow`의 'Clear Points' 버튼의 `clicked` 시그널을 `OpenGLWidget.clear_points` 함수에 연결하여 기능 활성화.

### 6. 2D/3D 뷰 모드 전환 기능 구현

- **`set_view_mode()` 메서드:** `OpenGLWidget`에 `set_view_mode(mode)` 메서드를 추가하여 `self.view_mode`를 변경하고, `resizeGL`을 호출하여 투영을 재설정하며, `update()`를 통해 화면을 갱신.
- **'Clear Points' 버튼 개선:** `clear_points()` 함수를 수정하여, 3D 뷰 모드에서 호출될 경우 점을 지우고 자동으로 2D 편집 모드로 전환되도록 함.
- **툴바 액션 연결:**
  - 'Add Point' 액션 클릭 시 `glWidget.set_view_mode('2D')` 호출.
  - 'Create SOR' 액션 클릭 시 `glWidget.set_view_mode('3D')` 호출.

### 7. 3D 뷰 렌더링 오류 수정 및 UI 로직 개선

- **3D 뷰 오류 수정 (최종):** 뷰 전환 시 렌더링이 즉시 갱신되지 않고 창 크기를 조절해야만 보이는 불안정한 상태의 원인을 분석하고 해결.
  - **원인:** 뷰 모드 전환 시 `set_view_mode`에서 `update()`만 호출할 경우, `paintGL`은 실행되지만 투영 행렬을 설정하는 `resizeGL`은 호출되지 않아 이전 모드의 투영 행렬이 그대로 사용되는 타이밍 문제.
  - **해결:** 투영 행렬 설정 로직을 `setupProjection` 함수로 분리. 이 함수를 `resizeGL` 뿐만 아니라 `paintGL` 함수 시작 부분에서도 매번 호출하도록 변경. 이로써 매 프레임마다 현재 뷰 모드에 맞는 투영 상태를 보장하여, 뷰 전환 시 즉시 올바른 화면이 렌더링되도록 문제를 완전히 해결.
- **UI 로직 개선:**
  - **역할 분리:** 'Clear Points' 버튼은 점 삭제 기능만 수행하도록 단순화. 뷰 전환은 상단 툴바('2D Edit', '3D View')가 전담하도록 역할을 명확히 분리.
  - **컨트롤 비활성화:** 3D 뷰 모드에서는 점 편집이 불가능하도록, `OpenGLWidget`에서 `viewModeChanged` 시그널을 보내면 `MainWindow`가 이를 받아 'Clear Points' 버튼을 비활성화하도록 시그널-슬롯 메커니즘을 구현.

### 8. 프로파일 곡선 시각화

- `draw_points` 함수를 수정하여, `GL_POINTS`로 점을 그리는 것에 더해 `GL_LINE_STRIP`을 사용하여 점들을 순서대로 잇는 선을 함께 그리도록 변경.
- 이를 통해 사용자는 자신이 만들고 있는 단면(프로파일)의 형태를 점을 찍는 과정에서 직관적으로 파악할 수 있게 됨.

### 9. SOR 모델 생성 준비: 단면 개수 UI 및 데이터 구조

- **단면 개수 UI 추가:** 컨트롤 패널에 'Number of Slices:' 레이블과 `QSpinBox`를 추가하여 사용자가 SOR 모델의 회전 단면 개수를 설정할 수 있도록 함. `QSpinBox`의 값 범위는 3에서 100으로 설정하고, 기본값은 30으로 지정.
- **`OpenGLWidget`에 데이터 구조 및 메서드 추가:**
  - `self.num_slices`: 회전 단면 개수를 저장하는 변수.
  - `self.sor_vertices`: 생성된 SOR 모델의 정점 데이터를 저장할 리스트.
  - `self.sor_faces`: 생성된 SOR 모델의 면 데이터를 저장할 리스트.
  - `set_num_slices(value)`: `QSpinBox`의 값 변경에 따라 `self.num_slices`를 업데이트하는 메서드.
  - `generate_sor_model()`: `self.points`를 기반으로 SOR 모델의 정점과 면 데이터를 생성하는 플레이스홀더 메서드.
  - `draw_sor_model()`: 생성된 SOR 모델을 그리는 플레이스홀더 메서드.
- **기능 연결:**
  - `set_view_mode`에서 '3D' 모드로 전환될 때, `self.points`가 존재하면 `generate_sor_model()`을 호출하여 모델 생성을 시도.
  - `paintGL`에서 '3D' 모드일 때, `self.sor_vertices`가 존재하면 `draw_sor_model()`을 호출하여 모델을 그리고, 그렇지 않으면 `draw_axes()`를 호출.
  - `clear_points` 함수가 호출될 때, `self.points`뿐만 아니라 `self.sor_vertices`와 `self.sor_faces`도 함께 초기화하여 모델 데이터를 리셋.
- **UI 활성화 제어:** `on_view_mode_changed` 슬롯에서 2D 모드일 때 `QSpinBox`를 활성화하고, 3D 모드일 때 비활성화하여 일관된 사용자 경험을 제공.
